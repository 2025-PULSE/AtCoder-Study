'''
세로 H행, 가로 W열의 격자
i,j
초기 상태에서 S_ij가 #이면 i,j 칸은 검은색, .이면 흰색으로 칠해져있다.
다음 연산을 10**100번 수행한다.(엄청 많이 하네)
T를 흰색이면서 인접한 칸 중 정확히 한 칸만 검은 색인 모든 칸의 집합이라고 할 때, 집합 T에 속하는 모든 칸을 검은색으로 칠한다.
여기서 인접한 칸이란 |i1-i2|+|j1-j2|=1일 때를 말한다. 그러니깐 상하좌우로 한칸 차이를 의미하네요.
모든 연산이 끝난 후 검은색인 칸의 개수를 구하여라.
H,W 2..
HW ..3*10^5
내 생각에 10*100을 하면 검은색 한칸만 있어도 전부 칠해질거 같은데, 한번 검증해보자.
00000
00000
00100
00000
00000

00000
00100
01110
00100
00000

00100
00100
11111
00100
00100

01110
10101
11111
10101
01110

=25-8=17
전혀 아니네
일단 10**100을 다하면 무조건 터지게 되고, 1로 찍힌 곳이 동시다발적으로 확장이 되어야 한다.
한칸 한칸 씩 다 보면 (3*10^5)^2 만큼 봐야하니깐 문제가 발생한다. 그러면 지금 해결해야하는 것이
동시다발적으로 확장이 일어나야하고, 전체를 보지않으면서 해결해야하네
그러면 이웃이 하나이면서 흰색인 친구를 모은 큐(안에는 위치정보가 들어감)를 통해서 검게 칠한다음에, 큐에 또 집어 넣고는 방식으로
그러면 큐에 어떻게 집어 넣을 것인가 이웃들을 검사하는 로직을 해보자.
일단 스켈레톤 코드부터


'''
from collections import deque
h,w=map(int,input().split())
l=[input() for _ in range(h)]
print(h,w)
print(l)