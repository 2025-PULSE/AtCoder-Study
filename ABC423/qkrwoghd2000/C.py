'''
B번이랑 같은 형태의 구조이다.
다만 다른 점은 모든 문이 닫히게 만들려면 필요한 최소 스위칭 갯수를 구하는 것이다.
모두 1로 만들면 된다.
문제를 오독했다.
R위치에 있는 사람이 직접 돌아다니면서 1로 다 만들어주는 거다. 즉 0으로 이동하는 것도 고려해서 가야한다.
i번쨰 문을 스위칭 할려면 i-1, i 위치에 방에서만 스위칭이 가능하다.
방 0~n, 문 n(1~n)개
1인 문을 지나가려면 2번의 스위칭이 필요하고 0은 1번의 스위칭만 하면 된다.
이동횟수를 묻는게 아니니, 우측으로 갔을 때, 최솟값이랑, 좌측으로 갔을 때, 최소 횟수를 비교해서 작은 쪽을 하면 될 거 같다.
6 3
1 0 0 1 0 0
좌측 기준 1 0 0
우측 기준 1 0 0
제일 좌측이랑 우측에 0으로 되어 있는 문이 있다면 무조건 거기로 가야하고
좌측을 l, 우측을 r이라고 할 떄, 그 사이는 무조건 지나가야하는 고정 비용이다.
그러면 1인 거에는 *2, 0인거는 1을 해서 더하면 답을 구할 수 있다.
위에 예시로 보면
l=1, r=5
1,5사이에 있는 
0 1 0과 0,0 두개를 더하면
4+2=6이 최소가 되게 된다.
R의 위치를 기준으로 시작하자. 좌측 기준을 구하는 건 0~R, 우측 기준은 R~N-1이 기준으로 구하면 된다.
틀렸다고 나왔다. 이걸 어떻게 해야할까
엣지케이스 생각해보자
2 0
0 0
2가 나와야 하는데 1이 나왔다.
반복문에 범위를 잘못 지정했었네
런타임 에러가 나왔다.
범위를 인위적으로 바꾸닌 런타임 에러가 굉장히 많이 나왔다.
5번 도전해서 AC가 나왔다. 애초에 전체에서 고정비용을 산출해서 하는데 R기준으로 안 나눠도 된다는 걸 알고, 다시 하나하나 다시 갈아 엎으니 해결이 되었다.
wa,re,re,ac
'''
n,r=map(int,input().split())
l=list(map(int,input().split()))
dl=-1
dr=-1
s=0

for i in range(0,n):
    if l[i]==0:
        dl=i
        break

if dl==-1:
    print(0)
    exit()

for i in range(n-1,-1,-1):
    if l[i]==0:
        dr=i
        break

s+=1
if dl!=dr:
    s+=1

if r<dl:
    s+=2*(dl-r)
elif r>=dr+1:
    s+=2*(r-(dr+1))

for i in range(dl+1,dr):
    if l[i]==0:
        s+=1
    elif l[i]==1:
        s+=2

print(s)